---
title: "SICP 第一章 构造过程抽象 (WIP)"
description: "SICP 第一章的习题及读书笔记"
pubDate: "Jul 11 2024"
---

import SchemeCode from "../../components/SchemeCode.tsx"
import Todo from "../../components/Todo.astro"

# 1.1 程序设计的基本元素

- **应用序**：先求值参数而后应用，先不求出运算对象的值，直到实际需要它们的值时再去做。
- **正则序**：完全展开而后归约，首先对运算符和各个运算对象求值，而后将得到的过程应用于得到的实际参数。

## 练习 1.1
<SchemeCode client:load code={`
(define a 3)
(define b (+ a 1))

(list 10
      (+ 5 3 4)
      (- 9 1)
      (/ 6 2)
      (+ (* 2 4) (- 4 6))
      (+ a b (* a b))
      (= a b)
      (if (and (> b a) (< b (* a b))) b a)
      (cond [(= a 4) 6]
            [(= b 4) (+ 6 7 a)]
            [else 25])
      (+ 2 (if (> b a) b a))
      (+ (cond [(> a b) a]
               [(< a b) b]
               [else -1])
         (+ a 1)))
`}/>

## 练习 1.2

将下面的表达式变换为前缀形式
$$
\frac
  {5+4+\left(2-\left(3-\left(6+\frac{4}{5}\right)\right)\right)}
  {3\left(6-2\right)\left(2-7\right)}
$$

<SchemeCode client:load code={`
(/ (+ 5 4 (- 2 (- 3 (+ 6 (/ 4 5)))))
   (* 3 (- 6 2) (- 2 7)))
`}/>

## 练习 1.3

定义一个过程，它以三个数作为参数，返回这较大的两个数之和

<SchemeCode client:load code={`
(define (sum-of-max-two a b c)
  (if (>= a b)
      (if (>= b c) (+ a b) (+ a c))
      (if (> a c) (+ b a) (+ b c))))

(sum-of-max-two 1 2 3)
`}/>

## 练习 1.4
<SchemeCode client:load code={`
(define (a-plus-abs-b a b)
  ((if (> b 0) + -) a b))

(list (a-plus-abs-b 1 1)
      (a-plus-abs-b 1 -1))
`}/>

这一过程中根据参数 `b` 的值来确定对参数 `a` `b` 应用的过程，如果 $b > 0$，则应用 `+` 过程；若 $b < 0$，则应用 `-` 过程。

## 练习 1.5

判定解释器采用的是应用序还是正则序

```scheme
(define (p) (p))

(define (test x y)
  (if (= x 0)
      0
      y))

(test 0 (p))
```

`p` 是一个死循环。如果采用应用序，则 `p` 必定会被求值，因此程序一定会卡死。如果采用正则序求值，当 `test` 函数的输入为 `0` 时，`if` 的条件满足，过程 `p` 不会被执行，程序输出 `0`。

## 实例 牛顿法求平方根
如果对 $x$ 的平方根的值有了一个猜测 $y$，那么就可以得到一个更好的猜测： $\frac{y + x/y}{2}$
<SchemeCode client:load code={`
(define (sqrt-iter guess x)
  (if (good-enough? guess x)
      guess
      (sqrt-iter (improve guess x)
                 x)))

(define (improve guess x)
  (average guess (/ x guess)))

(define (average x y)
  (/ (+ x y) 2))

(define (good-enough? guess x)
  (< (abs (- (square guess) x)) 0.001))

(define (square x) (* x x))

(define (sqrt x)
  (sqrt-iter 1.0 x))

(sqrt 9)
`}/>

## 练习 1.6
```scheme
(define (new-if predicate then-clause else-clause)
  (cond [predicate then-clause]
        [else else-clause]))
```
若采用应用序执行，无论判定条件如何， `then-clause` 和 `else-clause` 都一定会被执行，如果用 `new-if` 重写平方根程序，由于递归会无条件执行，程序永远无法终止。

## 练习 1.7
<Todo />

## 练习 1.8

牛顿法求立方根

如果 $y$ 是 $x$ 的立方根的一个近似值，那么下式将给出一个更好的近似值

$$
  \frac{x/y^2 + 2y}{3}
$$

<SchemeCode client:load code={`
(define (cube-root-iter guess x)
  (if (good-enough? guess x)
      guess
      (cube-root-iter (improve guess x) x)))

(define (good-enough? guess x)
  (< (abs (- (cube guess) x)) 0.001))

(define (improve guess x)
  (/ (+ (/ x (square guess)) (* 2 guess)) 3))

(define (square x)
  (* x x))

(define (cube x)
  (* x x x))

(define (cube-root x) (cube-root-iter 1.0 x))

(cube-root 27)
`} />

## 实例 内部定义与块结构

<SchemeCode client:load code={`
(define (sqrt x)
  (define (square x) (* x x))
  (define (average x y) (/ (+ x y) 2))
  (define (good-enough? guess x)
    (< (abs (- (square guess) x)) 0.001))
  (define (improve guess x)
    (average guess (/ x guess)))
  (define (sqrt-iter guess x)
    (if (good-enough? guess x)
        guess
        (sqrt-iter (improve guess x) x)))
  (sqrt-iter 1.0 x))

(sqrt 9)
`} />

# 1.2 过程及其产生的计算

## 实例 求阶乘函数
$$
n! = n \cdot (n - 1) \cdot (n - 2) \dots 3 \cdot 2 \cdot 1
$$

递归实现

$$
n! = n \cdot [(n - 1) \cdot (n - 2) \dots 3 \cdot 2 \cdot 1] = n \cdot (n - 1)!
$$

<SchemeCode client:load code={`
(define (factorial n)
  (if (= n 1)
      1
      (* n (factorial (- n 1)))))

(factorial 6)
`} />

求值过程 
```scheme
(factorial 6)
(* 6 (factorial 5))
(* 6 (* 5 (factorial 4)))
(* 6 (* 5 (* 4 (factorial 3))))
(* 6 (* 5 (* 4 (* 3 (factorial 2)))))
(* 6 (* 5 (* 4 (* 3 (* 2 (factorial 1))))))
(* 6 (* 5 (* 4 (* 3 (* 2 1)))))
(* 6 (* 5 (* 4 (* 3 2))))
(* 6 (* 5 (* 4 6)))
(* 6 (* 5 24))
(* 6 120)
720
```

迭代实现
$$
\begin{aligned}
\mathrm{product} & \gets \mathrm{counter} \cdot \mathrm{product} \\
\mathrm{counter} & \gets \mathrm{counter} + 1
\end{aligned}
$$

<SchemeCode client:load code={`
(define (factorial n)
  (define (fact-iter product counter max-count)
    (if (> counter max-count)
        product
        (fact-iter (* counter product)
                   (+ counter 1)
                   max-count)))
  (fact-iter 1 1 n))

(factorial 6)
`}/>


求值过程

```scheme
(factorial 6)
(fact-iter 1 1 6)
(fact-iter 1 2 6)
(fact-iter 2 3 6)
(fact-iter 6 4 6)
(fact-iter 24 5 6)
(fact-iter 120 6 6)
(fact-iter 720 7 6)
720
```
## 练习1.9

加法的递归版本
<SchemeCode client:load code={`
(define (inc x) (+ x 1))
(define (dec x) (- x 1))
(define (add a b)
  (if (= a 0)
      b
      (inc (add (dec a) b))))

(add 4 5)
`} />

```scheme
(+ 4 5)
(inc (+ 3 5))
(inc (inc (+ 2 5)))
(inc (inc (inc (+ 1 5))))
(inc (inc (inc (inc (+ 0 5)))))
(inc (inc (inc (inc 5))))
(inc (inc (inc 6)))
(inc (inc 7))
(inc 8)
9
```

加法的迭代版本
<SchemeCode client:load code={`
(define (inc x) (+ x 1))
(define (dec x) (- x 1))
(define (add a b)
  (if (= a 0)
      b
      (add (dec a) (inc b))))

(add 4 5)
`} />

```scheme
(+ 4 5)
(+ 3 6)
(+ 2 7)
(+ 1 8)
(+ 0 9)
9
```

## 练习1.10

Ackermann 函数

$$
\mathrm{A}(x, y) =
  \begin{cases}
    0 &, y = 0 \\
    2 y & , x = 0 \\
    2 & , y = 1 \\
    \mathrm{A}(x - 1, \mathrm{A}(x, (y - 1))) & , other
  \end{cases}
$$

<SchemeCode client:load code={`
(define (A x y)
  (cond [(= y 0) 0]
        [(= x 0) (* 2 y)]
        [(= y 1) 2]
        [else (A (- x 1)
                 (A x (- y 1)))]))

(list (A 1 10)
      (A 2 4)
      (A 3 3))
`} />

```scheme
(A 1 10)
(A (A 0 (A 1 9)))
(A (A 0 (A 0 (A 1 8))))
(A (A 0 (A 0 (A 0 (A 1 7)))))
(A (A 0 (A 0 (A 0 (A 0 (A 1 6))))))
(A (A 0 (A 0 (A 0 (A 0 (... (A 1 1)))))))

(A 1 1) => 2
(A 0 y) => (* 2 y)
(A 1 10) => (expt 2 10)
1024

(A 2 4)
(A 1 (A 2 3))
(A 1 (A 1 (A 2 2)))
(A 1 (A 1 (A 1 (A 2 1))))
(A 1 (A 1 (A 1 2)))
(A 1 (A 1 (expt 2 2)))
(A 1 (A 1 4))
(A 1 (expt 2 4))
(A 1 16)
(expt 2 16)
65536

(A 3 3)
(A 2 (A 3 2))
(A 2 (A 2 (A 3 1)))
(A 2 (A 2 2))
(A 2 (expt 2 2))
(A 2 4)
(expt 2 (expt 2 (expt 2 2)))
65536
```

$$
\begin{aligned}
  \mathrm{A}(0, n) &= 2 \\
  \mathrm{A}(1, n) &= 2^n \\
  \mathrm{A}(2, n) &= \underbrace{2^{\cdot^{\cdot^{\cdot^2}}}}_n
\end{aligned}
$$

## 实例 斐波那契数列

<SchemeCode client:load code={`
(define (fib n)
  (cond ((= n 0) 0)
        ((= n 1) 1)
        (else (+ (fib (- n 1))
                 (fib (- n 2))))))

(define (f n)
  (define (g i) 
    (if (= i n)
        (cons (fib i) '())
        (cons (fib i) (g (+ i 1)))))
  (g 1))

(f 10)
`} />

<SchemeCode client:load code={`
(define (fib n)
  (define (fib-iter a b count)
    (if (= count 0)
        b
        (fib-iter (+ a b) a (- count 1))))

  (fib-iter 1 0 n))

(define (f n)
  (define (g i) 
    (if (= i n)
        (cons (fib i) '())
        (cons (fib i) (g (+ i 1)))))
  (g 1))

(f 10)
`} />

## 实例 换零钱方式的统计

<SchemeCode client:load code={`
(define (count-change amount)
  (cc amount 5))

(define (cc amount kinds-of-coins)
  (cond ((= amount 0) 1)
        ((or (< amount 0) (= kinds-of-coins 0)) 0)
        (else (+ (cc amount
                     (- kinds-of-coins 1))
                 (cc (- amount (first-denomination kinds-of-coins))
                     kinds-of-coins)))))

(define (first-denomination kinds-of-coins)
  (cond ((= kinds-of-coins 1) 1)
        ((= kinds-of-coins 2) 5)
        ((= kinds-of-coins 3) 10)
        ((= kinds-of-coins 4) 25)
        ((= kinds-of-coins 5) 50)))

(count-change 100)
`} />

## 练习 1.11

$$
f = \begin{cases}
n &, n < 3 \\
f(n - 1) + 2 f(n - 2) + 3 f(n - 3) &, n \ge 3
\end{cases}
$$

<SchemeCode client:load code={`
(define (f n)
  (if (< n 3)
      n
      (+ (f (- n 1))
         (* 2 (f (- n 2)))
         (* 3 (f (- n 3))))))

(f 10)
`} />

<SchemeCode client:load code={`
(define (f n)
  (define (f-iter i f-n-1 f-n-2 f-n-3)
    (if (> i n)
        f-n-1
        (f-iter (+ i 1)
                (+ f-n-1 (* 2 f-n-2) (* 3 f-n-3))
                f-n-1
                f-n-2)))
  (if (< n 3)
      n
      (f-iter 3 2 1 0)))
(f 10)
`}/>

## 练习 1.12

计算帕斯卡三角形

<SchemeCode client:load code={`
(define (pascal-triangle n-row n-col)
  (if (= n-row 1)
      (if (= n-col 1) 1 0)
      (if (and (> n-col 0) (<= n-col n-row))
          (+ (pascal-triangle (- n-row 1) (- n-col 1))
             (pascal-triangle (- n-row 1) n-col))
          0)))

(define (print-pascal-triangle n)
  (define (iter i)
    (define (iter* j)
      (cond ((> j i) '())
            (else (display (pascal-triangle i j))
                  (display " ")
                  (iter* (+ j 1)))))

    (cond ((> i n) '())
          (else (iter* 1)
                (newline)
                (iter (+ i 1)))))
  (iter 1))

(print-pascal-triangle 5)
`}/>

## 练习 1.13
$$
\phi = \frac{1+\sqrt{5}}{2},\ \psi = \frac{1-\sqrt{5}}{2}
$$

令$ f(x) = \frac{\phi^2 - \psi^2}{\sqrt{5}} $

$$
\begin{aligned}
f(1)
&= \frac{\phi - \psi}{\sqrt{5}}
= \frac{1+\sqrt{5} - (1-\sqrt{5})}{2\sqrt{5}}
= \frac{2\sqrt{5}}{2\sqrt{5}}
= 1
= \mathrm{Fib}(1) \\

f(2)
&= \frac{\phi^2 - \psi^2}{\sqrt{5}}
= \frac{(1+\sqrt{5})^2 - (1-\sqrt{5})^2}{4\sqrt{5}}
= \frac{4\sqrt{5}}{4\sqrt{5}}
= 1
= \mathrm{Fib}(2)
\end{aligned}
$$

假设 $ \mathrm{Fib}(n) = f(n) $

$$
\newcommand{\Fib}{\mathrm{Fib}}

\begin{split}
\Fib(n) &= \Fib(n - 1) + \Fib(n - 2) \\
&= f(n - 1) + f(n - 1) \\
&= \frac{(\phi^{n - 1} - \psi^{n - 1}) + (\phi^{n - 2} - \psi^{n - 2})}{\sqrt{5}} \\
&= \frac{(\phi^{n - 1} + \phi^{n - 2}) - (\psi^{n - 1} + \psi^{n - 2})}{\sqrt{5}} \\
&= \frac{\phi^n(\phi^{-1} + \phi^{-2}) - \psi^n(\psi^{-1} + \psi^{-2})}{\sqrt{5}}
\end{split}
$$

$$
\begin{aligned}
\phi^{-1} + \phi^{-2} &= \frac{2}{1 + \sqrt{5}} + \frac{4}{1 + (\sqrt{5})^2} = \frac{6 + 2\sqrt{5}}{6 + 2\sqrt{5}} = 1 \\
\psi^{-1} + \psi^{-2} &= \frac{2}{1 - \sqrt{5}} + \frac{4}{(1 - \sqrt{5})^2} = \frac{6 - 2\sqrt{5}}{6 - 2\sqrt{5}} = 1
\end{aligned}
$$

$$
\mathrm{Fib}(n) = \frac{\phi^n - \psi^n}{\sqrt{5}} 
$$

$ \mathrm{Fib}(n) = f(n) $ 成立

$$
\newcommand{\Fib}{\mathrm{Fib}}

\begin{split}
\left| \Fib(n) - \frac{\phi^n}{\sqrt{5}} \right|
&= \left| \frac{\phi^n - \psi^n}{\sqrt{5}} - \frac{\phi^n}{\sqrt{5}} \right| \\
&= \left| - \frac{\psi^n}{\sqrt{5}} \right| \\
&= \frac{(\sqrt{5} - 1)^n}{2^n\sqrt{5}}
\end{split}
$$

当 $ n \in [1, \infty] $ 时，

$$
\newcommand{\Fib}{\mathrm{Fib}}
\left| \Fib(n) - \frac{\phi^n}{\sqrt{5}} \right| < \frac{1}{2}
$$

成立


## 练习 1.14
<Todo/>

## 练习 1.15
<Todo />

## 实例 求幂

直接翻译为递归定义
$$
\begin{aligned}
b^n &= b \cdot b^{n - 1} \\
b^0 &= 1
\end{aligned}
$$

<SchemeCode client:load code={`
(define (expt b n)
  (if (= n 0)
      1
      (* b (expt b (- n 1)))))

(expt 2 8)
`} />


使用迭代实现
<SchemeCode client:load code={`
(define (expt b n)
  (define (iter b counter product)
    (if (= counter 0)
        product
        (iter b (- counter 1) (* product b))))
  (iter b n 1))

(expt 2 8)
`} />

通过连续求平方，使用更少的步骤完成乘幂运算

$$
b^n = \begin{cases}
(b^{n/2})^2 &, n \text{是偶数} \\
b^n=b \cdot b^{n - 1} &,n \text{是奇数}
\end{cases}
$$

<SchemeCode client:load code={`
(define (fast-expt b n)
  (define (square x) (* x x))
  (cond [(= n 0) 1]
        [(even? n) (square (fast-expt b (/ n 2)))]
        [else (* b (fast-expt b (- n 1)))]))

(fast-expt 2 8)
`} />


## 练习 1.16

将快速求幂函数修改为迭代实现

> **定义一个不变量，要求它在状态之间保持不变，这一技术是思考迭代算法设计问题时的一种非常强有力的方法**

当 $n$ 为偶数时

$$
a(b^n) = a(b^{n/2})^2 = a(b^2)^{n/2} = a'b'^{n'}
$$

$$
\begin{aligned}
a' &= a \\
b' &= b^2 \\
n' &= n/2
\end{aligned}
$$

当 $n$ 为奇数时

$$
a(b^n) = a b b^{n - 1} = (a b)b^{n - 1} = a'b'^{n'}
$$

$$
\begin{aligned}
a' &= a b \\
b' &= b \\
n' &= n - 1
\end{aligned}
$$

<SchemeCode client:load code={`
(define (fast-expt b n)
  (define (square x) (* x x))
  (define (fast-expt-iter a b n)
    (cond [(= n 0) a]
          [(even? n) (fast-expt-iter a (square b) (/ n 2))]
          [else (fast-expt-iter (* a b) b (- n 1))]))

  (fast-expt-iter 1 b n))

(fast-expt 2 8)
`} />

## 练习 1.17

使用累加法求乘积

$$
a \cdot b = a + a \cdot (b - 1)
$$

<SchemeCode client:load code={`
(define (* a b)
  (if (= b 0)
      0
      (+ a (* a (- b 1)))))

(* 2 8)
`} />

利用 `double` 和 `halve` 在对数时间内求乘积

$$
a \cdot b =
\begin{cases}
(2 \cdot a) \cdot (\frac{1}{2} \cdot b) &, b \text{是偶数} \\
a \cdot (b - 1) + a &, b \text{是奇数} \\
a &, b = 1
\end{cases}
$$

<SchemeCode client:load code={`
(define (double x) (* 2 x))
(define (halve x) (/ x 2))

(define (fast-mul a b)
  (cond [(= b 1) a]
        [(even? b) (double (fast-mul a (halve b)))]
        [else (+ a (fast-mul a (- b 1)))]))

(fast-mul 2 8)
`} />

## 练习 1.18

将 1.17 改为迭代实现

$$
a \times b + c = \begin{cases}
(a \cdot 2) \cdot (\frac{1}{2} \cdot b) + c &,\ b \text{为偶数} \\
a \times (b - 1) + (c + a) &,\ b \text{为奇数} \\
c &,\ b = 0
\end{cases}
$$

<SchemeCode client:load code={`
(define (double x) (* 2 x))
(define (halve x) (/ x 2))

(define (fast-mul a b)
  (define (fast-mul-iter a b c)
    (cond [(= b 0) c]
          [(even? b) (fast-mul-iter (double a) (halve b) c)]
          [else (fast-mul-iter a (- b 1) (+ c a))]))
  (fast-mul-iter a b 0))

(fast-mul 3 4)
`} />

## 练习 1.19
$$
\begin{aligned}
a &\gets b q + a q + a p \\
b &\gets b p + a q
\end{aligned}
$$

$$
\begin{aligned}
a' &= b q + a q + a p \\
b' &= b p + a q \\
a'' &= b' q + a' q + a' p \\
    &= (b p + a q) q + (b q + a q + a p) q + (b q + a q + a p) p \\
    &= b p q + a q^2 + b q^2 + a q^2 + a p q + b p q + a p q + a p^2 \\
    &= (p^2 + 2 q^2 + 2 p q)a + (q^2+2 p q)b \\
    &= b(q^2 + 2 p q) + a(q^2 + 2 p q) + a(p^2 + q^2) \\
b'' &= b'p + a'q \\
    &= (b p + a q)p + (b q + a q + a p)q \\
    &= b p^2 + a p q + b q^2 + a q^2 + a p q \\
    &= (q^2 + 2 p q)a + (p ^ 2 + q^2)b \\
    &= b(p^2 + q^2) + a(q^2 + 2p q)
\end{aligned}
$$

$$
\begin{aligned}
p' &= p^2 + q^2 \\
q' &= q^2 + 2 p q
\end{aligned}
$$

<SchemeCode client:load code={`
(define (fib n)
  (define (square x) (* x x))
  (define (fib-iter a b p q count)
    (cond [(= count 0) b]
          [(even? count) (fib-iter a
                                   b
                                   (+ (square p) (square q))
                                   (+ (square q) (* 2 p q))
                                   (/ count 2))]
          [else (fib-iter (+ (* b q) (* a q) (* a p))
                          (+ (* b p) (* a q))
                          p
                          q
                          (- count 1))]))
  (fib-iter 1 0 0 1 n))

(define (f n)
  (define (g i) 
    (if (= i n)
        (cons (fib i) '())
        (cons (fib i) (g (+ i 1)))))
  (g 1))

(f 10)
`} />

## 练习1.20 使用正则序和应用序时 `remainder` 的调用次数

* Normal Order: fully expand and then reduce
* Applicative Order: evaluate the arguments and then apply

## 实例 素数检测
$$
\Theta (\sqrt{n})
$$

```scheme
(define (smallest-divisor n)
  (find-divisor n 2))

(define (divides? a  b)
  (= (remainder b a) 0))

(define (find-divisor n test-divisor)
  (cond [(> (square test-divisor) n) n]
        [(divides? test-divisor n) test-divisor]
        [else (find-divisor n (+ test-divisor 1))]))

(define (prime? n)
  (= n (smallest-divisor n)))
```

> [!NOTE]
> **费马小定理**：如果 $n$ 是一个素数， $a$ 是小于 $n$ 的任意正整数，那么 $a$ 的 $n$ 次方与 $a$ 模同余。（两个数称为是模 $n$ 同余，如果它们除以 $n$ 的余数相同。数 $a$ 除以 $n$ 的余数称为 $a$ 取模 $n$ 的余数，或简称为 $a$ 取模 $n$ ）

对于指数 $e > 1$ 的情况，所采用的规约方式基于以下事实：
对任意的 $x, y, m$ ，有

$$
x\ y\ mod\ m = (x\ mod\ m)(y\ mod\ m)\ mod\ m
$$

例如：在 $e$ 是偶数时，

$$
b^e\ mod\ m = (b^{\frac{e}{2}}\ mod\ m)^2\ mod\ m
$$

```scheme
(define (expmod base exp m)
  (cond [(= exp 0) 1]
        [(even? exp)
         (remainder (square (expmod base (/ exp 2) m))
                    m)]
        [else
         (remainder (* base (expmod base (- exp 1) m))
                    m)]))

(define (fermat-test n)
  (define (try-it a)
    (= (expmod a n n) a))
  (try-it (+ 1 (random (- n 1)))))

(define (fast-prime? n times)
  (cond [(= times 0) true]
        [(fermat-test n) (fast-prime? n (- times 1))]
        [else false]))
```

## 练习 1.21 找出 199、1999、19999的最小公因子
```scheme
(smallest-divisor 199)
; 199
(smallest-divisor 1999)
; 1999
(smallest-divisor 19999)
; 7
```
## 练习 1.22 找出指定范围内最小的素数
```scheme
(define (timed-prime-test n)
  (newline)
  (display n)
  (start-prime-test n (runtime)))

(define (start-prime-test n start-time)
  (if (prime? n)
      (report-prime (- (runtime) start-time)) #f))

(define (report-prime elapsed-time)
  (display " *** ")
  (display elapsed-time)
  #t)

(define (search-for-primes n)
  (if (even? n)
      (search-for-primes (+ n 1))
      (if (not (timed-prime-test n))
          (search-for-primes (+ n 2)))) )

(search-for-primes 100000)
(search-for-primes 1000000)
(search-for-primes 10000000)

; 100001
; 100003 *** 1
; 1000001
; 1000003 *** 4
; 10000001
; 10000003
; 10000005
; 10000007
; 10000009
; 10000011
; 10000013
; 10000015
; 10000017
; 10000019 *** 11
```

## 练习 1.23
TODO

## 练习 1.24
TODO

## 练习 1.25
溢出

## 练习 1.26
$$
2^{\log_2{n}} = n
$$

## 练习1.27 证明 Carmichael 数能够骗过费马检查

```scheme
(define (full-fermat-test n)
  (define (full-fermat-test-iter a)
    (cond [(= a 1) #t]
          [(not (= (expmod a n n) (remainder a n))) #f]
          [else (full-fermat-test-iter (- a 1))]))
  (full-fermat-test-iter (- n 1)))

(define (run-full-fermat-test-on-carmichael-numbers)
  (display (full-fermat-test 561))
  (newline)
  (display (full-fermat-test 1105))
  (newline)
  (display (full-fermat-test 1729))
  (newline)
  (display (full-fermat-test 2465))
  (newline)
  (display (full-fermat-test 2821))
  (newline)
  (display (full-fermat-test 6601))
  (newline))
```

## 练习 1.28
TODO

## 练习 1.29 使用辛普森规则求积分
```scheme
(define (simpson-integral f a b n)
  (define (h) (/ (- b a) n))
  (define (y k)
    (f (+ a (* k (h)))))
  (define (t k)
    (cond [(or (= k 0) (= k n)) (y k)]
          [(even? k) (* 2 (y k))]
          [else (* 4 (y k))]))
  (* (/ (h) 3.0)
     (sum t 0 inc n)))
```
```scheme
(simpson-integral cube 0 1 100)
; 0.25
(simpson-intergral cube 0 1 1000)
; 0.25
```

## 练习 1.30 基于迭代的求和函数
```scheme
(define (sum* term a next b)
  (define (iter a result)
    (if (> a b)
        result
        (iter (+ a 1) (+ (term a) result))))
  (iter a 0))
```

## 练习 1.31 求 $\pi$ 值

$$
\prod_{n=1}^{\infty}\left(\frac{2n}{2n - 1} \cdot \frac{2n}{2n + 1}\right)
$$

```scheme
(define (product factor a next b)
  (if (> a b)
      1
      (* (factor a) (product factor (next a) next b))))

(define (factorial x)
  (product identity 1 inc x))

(define (product* factor a next b)
  (define (iter a result)
    (if (> a b)
        result
        (iter (+ a 1) (* (factor a) result))))
  (iter a 1))

(define (wallis-product n)
  (define (inc x) (+ 1 x))
  (define (fact n) (* (/ (* 2 n)
                         (- (* 2 n) 1))
                      (/ (* 2 n)
                         (+ (* 2 n) 1))))
  (product* fact 1.0 inc n))
```

## 练习 1.32 使用`accumulate`实现`sum`和`product`
```scheme
(define (accmulate combiner null-value term a next b)
  (if (> a b)
      null-value
      (combiner (term a)
                (accmulate combiner
                           null-value
                           term
                           (next a)
                           next
                           b))))

(define (sum-alt term a next b)
  (accmulate + 0 term a next b))

(define (prod-alt factor a next b)
  (accmulate * 1 factor a next b))

(define (accmulate* combiner null-value term a next b)
  (define (iter n result)
    (if (> n b)
        result
        (iter (next n) (combiner (term n) result))))
  (iter a null-value))

(define (sum-alt* term a next b)
  (accmulate* + 0 term a next b))

(define (prod-alt* factor a next b)
  (accmulate* * 1 factor a next b))
```

## 练习 1.33 `accumulate` + `filter`
```scheme
(define (filtered-accumulate filter
                             combiner
                             null-value
                             term
                             a
                             next
                             b)
  (define (iter n result)
    (cond [(> n b) result]
          [(not (filter (term n))) (iter (next n) result)]
          [else (iter (next n) (combiner n result))]))
  (iter a null-value))

(define (square x) (* x x))

(define (smallest-divisor n)
  (find-divisor n 2))

(define (divides? a b)
  (= (remainder b a) 0))

(define (find-divisor n test-divisor)
  (cond [(> (square test-divisor) n) n]
        [(divides? test-divisor n) test-divisor]
        [else (find-divisor n (+ test-divisor 1))]))

(define (prime? n)
  (if (= n 1) #f
      (= n (smallest-divisor n))))

(define (prime-sum a b)
  (filtered-accumulate prime? + 0 identity a inc b))

(define (relative-prime? i n)
  (= (gcd i n) 1))

(define (product-of-relative-prime n)
  (define (relative-prime? i)
    (= (gcd i n) 1))
  (filtered-accumulate relative-prime? * 1 identity 1 inc n))
```
## 练习 1.34 `(f f)`

```scheme
application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 2
```

## 实例 通过区间折半寻找方程的根

```scheme
(define (average x y) (/ (+ x y) 2))

(define (search f neg-point pos-point)
  (define (close-enough? x y)
    (< (abs (- x y)) 0.001))

  (let ([midpoint (average neg-point pos-point)])
    (if (close-enough? neg-point pos-point)
        midpoint
        (let ([test-value (f midpoint)])
          (cond [(positive? test-value)
                  (search f neg-point midpoint)]
                [(negative? test-value)
                 (search f midpoint pos-point)])))))

(define (half-interval-method f a b)
  (let ((a-value (f a))
        (b-value (f b)))
    (cond [(and (negative? a-value) (positive? b-value))
            (search f a b)]
           [(and (negative? b-value) (positive? a-value))
            (search f b a)]
           [else
            (error "Values are not of opposite sign" a b)])))

(half-interval-method sin 2.0 4.0)
(half-interval-method (lambda (x) (- (* x x x) (* 2 x) 3))
                      1.0
                      2.0)
```

## 实例 找出函数的不动点
数 $x$ 称为函数 $f$ 的不动点，如果 $x$ 满足方程 $f(x) = x$。对于某些函数，通过从某个初始猜测出发，反复应用 $f$

$$
f(x), f(f(x)), f(f(f(x))), \dots
$$

知道值的变化不大时，就可以找到它的一个不动点。

```scheme
(define (fixed-point f first-guess)
  (define (close-enough? v1 v2)
    (< (abs (- v1 v2)) tolerance))
  (define (try guess)
    (let ([next (f guess)])
      (if (close-enough? guess next)
          next
          (try next))))
  (try first-guess))

(fixed-point cos 1.0)
(fixed-point (lambda (y) (+ (sin y) (cos y))) 1.0)

(define (sqrt x)
  (fixed-point (lambda (y) (average y (/ x y))) 1.0))

(sqrt 4)
```

## 练习 1.35 黄金分割率
```scheme
(fixed-point (lambda (x) (+ 1 (/ 1 x))) 1.0)
```

## 练习 1.36 $x^x = 1000$
```scheme
(define (fixed-point* f first-guess)
  (define (close-enough? v1 v2)
    (< (abs (- v1 v2)) tolerance))
  (define (try guess)
    (display guess)
    (display "; ")
    (let ([next (f guess)])
      (if (close-enough? guess next)
          next
          (try next))))
  (try first-guess))

(newline)
(fixed-point* (lambda (y) (/ (log 1000) (log y))) 1.5)
(newline)
(fixed-point* (lambda (y) (average y (/ (log 1000) (log y)))) 1.5)
```

## 练习 1.37 无穷连分式
```scheme
(define (cont-frac n d k)
  (define (inner i)
    (if (= i k)
        (/ (n i) (d i))
        (/ (n i) (+ (d i) (inner (+ i 1))))))
  (inner 1))

(define (cont-frac* n d k)
  (define (iter prev i)
    (if (= i 0)
        prev
        (iter (/ (n i) (+ (d i) prev)) (- i 1))))
  (iter 0 k))

(cont-frac (lambda (i) 1.0) (lambda (i) 1.0) 100)
(cont-frac* (lambda (i) 1.0) (lambda (i) 1.0) 100)
```

## 1.38 欧拉展开式

```scheme
(define (euler n)
  (cont-frac*
   (lambda (i) 1.0)
   (lambda (i)
     (if (= (remainder (+ i 1) 3) 0)
         (* (/ (+ i 1) 3) 2)
         1))
   n))

(+ (euler 100) 2)
```

## 1.39 正切函数的连分式

```scheme
(define (tan-cf x k)
  (cont-frac*
   (lambda (i)
     (if (= i 1) x (- (* x x))))
   (lambda (i)
     (- (* i 2) 1))
   k))

(tan-cf 3.1415926535 10000)
```

## 实例 平均阻尼 + 不动点算法
求 $y = x/y$ 不动点可以转换为求

$$
y \mapsto (1/2) (y + x/y)
$$

的不动点

```scheme
(define (average-damp f)
  (lambda (x) (average x (f x))))

(define (sqrt* x)
  (fixed-point (average-damp (lambda (y) (/ x y)))
               1.0))
```

## 实例 牛顿法
如果 $x \mapsto g(x)$ 是一个可微函数，那么方程 $g(x) = 0$的一个解就是函数 $x \mapsto f(x)$ 的一个不动点，其中：

$$
f(x) = x - \frac{g(x)}{Dg(x)}
$$

```scheme
(define (newton-transform g)
  (lambda (x)
    (- x (/ (g x) ((deriv g) x)))))

(define (newtons-method g guess)
  (fixed-point (newton-transform g) guess))

(define (sqrt-n x)
  (newtons-method (lambda (y) (- (square y) x))
                  1.0))
```

## 实例 抽象和第一级过程
```scheme
(define (fixed-point-of-transform g transform guess)
  (fixed-point (transform g) guess))

(define (sqrt-d* x)
  (fixed-point-of-transform (lambda (y) (/ x y))
                            average-damp
                            1.0))

(define (sqrt-n* x)
  (fixed-point-of-transform (lambda (y) (- (square y) x))
                            newton-transform
                            1.0))
```

## 练习 1.40 `cubic`
```scheme
(define (cubic a b c)
  (lambda (x)
    (+ (* x x x) (* a x x) (* b x) c)))

(newtons-method (cubic 1 1 1) 1)
```

## 练习 1.41 `double`
```scheme
(define (double f)
  (lambda (x)
    (f (f x))))

(((double (double double)) inc) 5)
; 21
```

## 练习 1.42 `compose`
```scheme
(define (compose f g)
  (lambda (x) (f (g x))))
```

## 练习 1.43 `repeated`
```scheme
(define (repeated f count)
  (define (iter counter inner-result)
    (if (= counter 0)
        inner-result
        (iter (- counter 1) (f inner-result))))
  (lambda (x) (iter count x)))

((repeated square 2) 5)
```

## 练习 1.44 `smooth`
```scheme
(define (smooth f)
  (define (dx) 0.0001)
  (lambda (x)
    (/ (+ (f (- x dx)) (f x) (f (+ x dx))) 3)))
```

## 练习 1.45

TODO

## 练习 1.46

TODO