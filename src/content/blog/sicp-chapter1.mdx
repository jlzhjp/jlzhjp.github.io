---
title: "SICP 第一章 构造过程抽象 (WIP)"
description: "SICP 第一章的习题及读书笔记"
pubDate: "Jul 11 2024"
---

import SchemeCode from "../../components/SchemeCode.tsx"
import Todo from "../../components/Todo.astro"

# 1.1 程序设计的基本元素

- **应用序**：先求值参数而后应用，先不求出运算对象的值，直到实际需要它们的值时再去做。
- **正则序**：完全展开而后归约，首先对运算符和各个运算对象求值，而后将得到的过程应用于得到的实际参数。

## 练习 1.1
<SchemeCode client:load code={`
(define a 3)
(define b (+ a 1))

(list 10
      (+ 5 3 4)
      (- 9 1)
      (/ 6 2)
      (+ (* 2 4) (- 4 6))
      (+ a b (* a b))
      (= a b)
      (if (and (> b a) (< b (* a b))) b a)
      (cond [(= a 4) 6]
            [(= b 4) (+ 6 7 a)]
            [else 25])
      (+ 2 (if (> b a) b a))
      (+ (cond [(> a b) a]
               [(< a b) b]
               [else -1])
         (+ a 1)))
`}/>

## 练习 1.2

将下面的表达式变换为前缀形式

$$
\frac
  {5 + 4 + \left( 2 - \left( 3 - \left( 6 + \frac{4}{5} \right) \right) \right)}
  {3 \left (6 - 2 \right) \left(2 - 7 \right)}
$$

<SchemeCode client:load code={`
(/ (+ 5 4 (- 2 (- 3 (+ 6 (/ 4 5)))))
   (* 3 (- 6 2) (- 2 7)))
`}/>

## 练习 1.3

定义一个过程，它以三个数作为参数，返回这较大的两个数之和

<SchemeCode client:load code={`
(define (sum-of-max-two a b c)
  (if (>= a b)
      (if (>= b c) (+ a b) (+ a c))
      (if (> a c) (+ b a) (+ b c))))

(sum-of-max-two 1 2 3)
`}/>

## 练习 1.4
<SchemeCode client:load code={`
(define (a-plus-abs-b a b)
  ((if (> b 0) + -) a b))

(list (a-plus-abs-b 1 1)
      (a-plus-abs-b 1 -1))
`}/>

这一过程中根据参数 `b` 的值来确定对参数 `a` `b` 应用的过程，如果 $b > 0$，则应用 `+` 过程；若 $b < 0$，则应用 `-` 过程。

## 练习 1.5

判定解释器采用的是应用序还是正则序

```scheme
(define (p) (p))

(define (test x y)
  (if (= x 0)
      0
      y))

(test 0 (p))
```

`p` 是一个死循环。如果采用应用序，则 `p` 必定会被求值，因此程序一定会卡死。如果采用正则序求值，当 `test` 函数的输入为 `0` 时，`if` 的条件满足，过程 `p` 不会被执行，程序输出 `0`。

## 实例 牛顿法求平方根
如果对 $x$ 的平方根的值有了一个猜测 $y$，那么就可以得到一个更好的猜测： $\frac{y + x/y}{2}$
<SchemeCode client:load code={`
(define (sqrt-iter guess x)
  (if (good-enough? guess x)
      guess
      (sqrt-iter (improve guess x)
                 x)))

(define (improve guess x)
  (average guess (/ x guess)))

(define (average x y)
  (/ (+ x y) 2))

(define (good-enough? guess x)
  (< (abs (- (square guess) x)) 0.001))

(define (square x) (* x x))

(define (sqrt x)
  (sqrt-iter 1.0 x))

(sqrt 9)
`}/>

## 练习 1.6
```scheme
(define (new-if predicate then-clause else-clause)
  (cond [predicate then-clause]
        [else else-clause]))
```
若采用应用序执行，无论判定条件如何， `then-clause` 和 `else-clause` 都一定会被执行，如果用 `new-if` 重写平方根程序，由于递归会无条件执行，程序永远无法终止。

## 练习 1.7
<Todo />

## 练习 1.8

牛顿法求立方根

如果 $y$ 是 $x$ 的立方根的一个近似值，那么下式将给出一个更好的近似值

$$
  \frac{x/y^2 + 2y}{3}
$$

<SchemeCode client:load code={`
(define (cube-root-iter guess x)
  (if (good-enough? guess x)
      guess
      (cube-root-iter (improve guess x) x)))

(define (good-enough? guess x)
  (< (abs (- (cube guess) x)) 0.001))

(define (improve guess x)
  (/ (+ (/ x (square guess)) (* 2 guess)) 3))

(define (square x)
  (* x x))

(define (cube x)
  (* x x x))

(define (cube-root x) (cube-root-iter 1.0 x))

(cube-root 27)
`} />

## 实例 内部定义与块结构

<SchemeCode client:load code={`
(define (sqrt x)
  (define (square x) (* x x))
  (define (average x y) (/ (+ x y) 2))
  (define (good-enough? guess x)
    (< (abs (- (square guess) x)) 0.001))
  (define (improve guess x)
    (average guess (/ x guess)))
  (define (sqrt-iter guess x)
    (if (good-enough? guess x)
        guess
        (sqrt-iter (improve guess x) x)))
  (sqrt-iter 1.0 x))

(sqrt 9)
`} />

# 1.2 过程及其产生的计算

## 实例 求阶乘函数
$$
n! = n \cdot (n - 1) \cdot (n - 2) \dots 3 \cdot 2 \cdot 1
$$

递归实现

$$
n! = n \cdot [(n - 1) \cdot (n - 2) \dots 3 \cdot 2 \cdot 1] = n \cdot (n - 1)!
$$

<SchemeCode client:load code={`
(define (factorial n)
  (if (= n 1)
      1
      (* n (factorial (- n 1)))))

(factorial 6)
`} />

求值过程 
```scheme
(factorial 6)
(* 6 (factorial 5))
(* 6 (* 5 (factorial 4)))
(* 6 (* 5 (* 4 (factorial 3))))
(* 6 (* 5 (* 4 (* 3 (factorial 2)))))
(* 6 (* 5 (* 4 (* 3 (* 2 (factorial 1))))))
(* 6 (* 5 (* 4 (* 3 (* 2 1)))))
(* 6 (* 5 (* 4 (* 3 2))))
(* 6 (* 5 (* 4 6)))
(* 6 (* 5 24))
(* 6 120)
720
```

迭代实现
$$
\begin{aligned}
\mathrm{product} & \gets \mathrm{counter} \cdot \mathrm{product} \\
\mathrm{counter} & \gets \mathrm{counter} + 1
\end{aligned}
$$

<SchemeCode client:load code={`
(define (factorial n)
  (define (fact-iter product counter max-count)
    (if (> counter max-count)
        product
        (fact-iter (* counter product)
                   (+ counter 1)
                   max-count)))
  (fact-iter 1 1 n))

(factorial 6)
`}/>


求值过程

```scheme
(factorial 6)
(fact-iter 1 1 6)
(fact-iter 1 2 6)
(fact-iter 2 3 6)
(fact-iter 6 4 6)
(fact-iter 24 5 6)
(fact-iter 120 6 6)
(fact-iter 720 7 6)
720
```
## 练习1.9

加法的递归版本
<SchemeCode client:load code={`
(define (inc x) (+ x 1))
(define (dec x) (- x 1))
(define (add a b)
  (if (= a 0)
      b
      (inc (add (dec a) b))))

(add 4 5)
`} />

```scheme
(+ 4 5)
(inc (+ 3 5))
(inc (inc (+ 2 5)))
(inc (inc (inc (+ 1 5))))
(inc (inc (inc (inc (+ 0 5)))))
(inc (inc (inc (inc 5))))
(inc (inc (inc 6)))
(inc (inc 7))
(inc 8)
9
```

加法的迭代版本
<SchemeCode client:load code={`
(define (inc x) (+ x 1))
(define (dec x) (- x 1))
(define (add a b)
  (if (= a 0)
      b
      (add (dec a) (inc b))))

(add 4 5)
`} />

```scheme
(+ 4 5)
(+ 3 6)
(+ 2 7)
(+ 1 8)
(+ 0 9)
9
```

## 练习1.10

Ackermann 函数

$$
\mathrm{A}(x, y) =
  \begin{cases}
    0 &, y = 0 \\
    2 y & , x = 0 \\
    2 & , y = 1 \\
    \mathrm{A}(x - 1, \mathrm{A}(x, (y - 1))) & , other
  \end{cases}
$$

<SchemeCode client:load code={`
(define (A x y)
  (cond [(= y 0) 0]
        [(= x 0) (* 2 y)]
        [(= y 1) 2]
        [else (A (- x 1)
                 (A x (- y 1)))]))

(list (A 1 10)
      (A 2 4)
      (A 3 3))
`} />

```scheme
(A 1 10)
(A (A 0 (A 1 9)))
(A (A 0 (A 0 (A 1 8))))
(A (A 0 (A 0 (A 0 (A 1 7)))))
(A (A 0 (A 0 (A 0 (A 0 (A 1 6))))))
(A (A 0 (A 0 (A 0 (A 0 (... (A 1 1)))))))

(A 1 1) => 2
(A 0 y) => (* 2 y)
(A 1 10) => (expt 2 10)
1024

(A 2 4)
(A 1 (A 2 3))
(A 1 (A 1 (A 2 2)))
(A 1 (A 1 (A 1 (A 2 1))))
(A 1 (A 1 (A 1 2)))
(A 1 (A 1 (expt 2 2)))
(A 1 (A 1 4))
(A 1 (expt 2 4))
(A 1 16)
(expt 2 16)
65536

(A 3 3)
(A 2 (A 3 2))
(A 2 (A 2 (A 3 1)))
(A 2 (A 2 2))
(A 2 (expt 2 2))
(A 2 4)
(expt 2 (expt 2 (expt 2 2)))
65536
```

$$
\begin{aligned}
  \mathrm{A}(0, n) &= 2 \\
  \mathrm{A}(1, n) &= 2^n \\
  \mathrm{A}(2, n) &= \underbrace{2^{\cdot^{\cdot^{\cdot^2}}}}_n
\end{aligned}
$$

## 实例 斐波那契数列

<SchemeCode client:load code={`
(define (fib n)
  (cond ((= n 0) 0)
        ((= n 1) 1)
        (else (+ (fib (- n 1))
                 (fib (- n 2))))))

(define (f n)
  (define (g i) 
    (if (= i n)
        (cons (fib i) '())
        (cons (fib i) (g (+ i 1)))))
  (g 1))

(f 10)
`} />

<SchemeCode client:load code={`
(define (fib n)
  (define (fib-iter a b count)
    (if (= count 0)
        b
        (fib-iter (+ a b) a (- count 1))))

  (fib-iter 1 0 n))

(define (f n)
  (define (g i) 
    (if (= i n)
        (cons (fib i) '())
        (cons (fib i) (g (+ i 1)))))
  (g 1))

(f 10)
`} />

## 实例 换零钱方式的统计

<SchemeCode client:load code={`
(define (count-change amount)
  (cc amount 5))

(define (cc amount kinds-of-coins)
  (cond ((= amount 0) 1)
        ((or (< amount 0) (= kinds-of-coins 0)) 0)
        (else (+ (cc amount
                     (- kinds-of-coins 1))
                 (cc (- amount (first-denomination kinds-of-coins))
                     kinds-of-coins)))))

(define (first-denomination kinds-of-coins)
  (cond ((= kinds-of-coins 1) 1)
        ((= kinds-of-coins 2) 5)
        ((= kinds-of-coins 3) 10)
        ((= kinds-of-coins 4) 25)
        ((= kinds-of-coins 5) 50)))

(count-change 100)
`} />

## 练习 1.11

$$
f = \begin{cases}
n &, n < 3 \\
f(n - 1) + 2 f(n - 2) + 3 f(n - 3) &, n \ge 3
\end{cases}
$$

<SchemeCode client:load code={`
(define (f n)
  (if (< n 3)
      n
      (+ (f (- n 1))
         (* 2 (f (- n 2)))
         (* 3 (f (- n 3))))))

(f 10)
`} />

<SchemeCode client:load code={`
(define (f n)
  (define (f-iter i f-n-1 f-n-2 f-n-3)
    (if (> i n)
        f-n-1
        (f-iter (+ i 1)
                (+ f-n-1 (* 2 f-n-2) (* 3 f-n-3))
                f-n-1
                f-n-2)))
  (if (< n 3)
      n
      (f-iter 3 2 1 0)))
(f 10)
`}/>

## 练习 1.12

计算帕斯卡三角形

<SchemeCode client:load code={`
(define (pascal-triangle n-row n-col)
  (if (= n-row 1)
      (if (= n-col 1) 1 0)
      (if (and (> n-col 0) (<= n-col n-row))
          (+ (pascal-triangle (- n-row 1) (- n-col 1))
             (pascal-triangle (- n-row 1) n-col))
          0)))

(define (print-pascal-triangle n)
  (define (iter i)
    (define (iter* j)
      (cond ((> j i) '())
            (else (display (pascal-triangle i j))
                  (display " ")
                  (iter* (+ j 1)))))

    (cond ((> i n) '())
          (else (iter* 1)
                (newline)
                (iter (+ i 1)))))
  (iter 1))

(print-pascal-triangle 5)
`}/>

## 练习 1.13
$$
\phi = \frac{1+\sqrt{5}}{2},\ \psi = \frac{1-\sqrt{5}}{2}
$$

令$ f(x) = \frac{\phi^2 - \psi^2}{\sqrt{5}} $

$$
\begin{aligned}
f(1)
&= \frac{\phi - \psi}{\sqrt{5}}
= \frac{1+\sqrt{5} - (1-\sqrt{5})}{2\sqrt{5}}
= \frac{2\sqrt{5}}{2\sqrt{5}}
= 1
= \mathrm{Fib}(1) \\

f(2)
&= \frac{\phi^2 - \psi^2}{\sqrt{5}}
= \frac{(1+\sqrt{5})^2 - (1-\sqrt{5})^2}{4\sqrt{5}}
= \frac{4\sqrt{5}}{4\sqrt{5}}
= 1
= \mathrm{Fib}(2)
\end{aligned}
$$

假设 $ \mathrm{Fib}(n) = f(n) $

$$
\newcommand{\Fib}{\mathrm{Fib}}

\begin{split}
\Fib(n) &= \Fib(n - 1) + \Fib(n - 2) \\
&= f(n - 1) + f(n - 1) \\
&= \frac{(\phi^{n - 1} - \psi^{n - 1}) + (\phi^{n - 2} - \psi^{n - 2})}{\sqrt{5}} \\
&= \frac{(\phi^{n - 1} + \phi^{n - 2}) - (\psi^{n - 1} + \psi^{n - 2})}{\sqrt{5}} \\
&= \frac{\phi^n(\phi^{-1} + \phi^{-2}) - \psi^n(\psi^{-1} + \psi^{-2})}{\sqrt{5}}
\end{split}
$$

$$
\begin{aligned}
\phi^{-1} + \phi^{-2} &= \frac{2}{1 + \sqrt{5}} + \frac{4}{1 + (\sqrt{5})^2} = \frac{6 + 2\sqrt{5}}{6 + 2\sqrt{5}} = 1 \\
\psi^{-1} + \psi^{-2} &= \frac{2}{1 - \sqrt{5}} + \frac{4}{(1 - \sqrt{5})^2} = \frac{6 - 2\sqrt{5}}{6 - 2\sqrt{5}} = 1
\end{aligned}
$$

$$
\mathrm{Fib}(n) = \frac{\phi^n - \psi^n}{\sqrt{5}} 
$$

$ \mathrm{Fib}(n) = f(n) $ 成立

$$
\newcommand{\Fib}{\mathrm{Fib}}

\begin{split}
\left| \Fib(n) - \frac{\phi^n}{\sqrt{5}} \right|
&= \left| \frac{\phi^n - \psi^n}{\sqrt{5}} - \frac{\phi^n}{\sqrt{5}} \right| \\
&= \left| - \frac{\psi^n}{\sqrt{5}} \right| \\
&= \frac{(\sqrt{5} - 1)^n}{2^n\sqrt{5}}
\end{split}
$$

当 $ n \in [1, \infty] $ 时，

$$
\newcommand{\Fib}{\mathrm{Fib}}
\left| \Fib(n) - \frac{\phi^n}{\sqrt{5}} \right| < \frac{1}{2}
$$

成立


## 练习 1.14
<Todo/>

## 练习 1.15
<Todo />

## 实例 求幂

直接翻译为递归定义
$$
\begin{aligned}
b^n &= b \cdot b^{n - 1} \\
b^0 &= 1
\end{aligned}
$$

<SchemeCode client:load code={`
(define (expt b n)
  (if (= n 0)
      1
      (* b (expt b (- n 1)))))

(expt 2 8)
`} />


使用迭代实现
<SchemeCode client:load code={`
(define (expt b n)
  (define (iter b counter product)
    (if (= counter 0)
        product
        (iter b (- counter 1) (* product b))))
  (iter b n 1))

(expt 2 8)
`} />

通过连续求平方，使用更少的步骤完成乘幂运算

$$
b^n = \begin{cases}
(b^{n/2})^2 &, n \text{是偶数} \\
b^n=b \cdot b^{n - 1} &,n \text{是奇数}
\end{cases}
$$

<SchemeCode client:load code={`
(define (fast-expt b n)
  (define (square x) (* x x))
  (cond [(= n 0) 1]
        [(even? n) (square (fast-expt b (/ n 2)))]
        [else (* b (fast-expt b (- n 1)))]))

(fast-expt 2 8)
`} />


## 练习 1.16

将快速求幂函数修改为迭代实现

> **定义一个不变量，要求它在状态之间保持不变，这一技术是思考迭代算法设计问题时的一种非常强有力的方法**

当 $n$ 为偶数时

$$
a(b^n) = a(b^{n/2})^2 = a(b^2)^{n/2} = a'b'^{n'}
$$

$$
\begin{aligned}
a' &= a \\
b' &= b^2 \\
n' &= n/2
\end{aligned}
$$

当 $n$ 为奇数时

$$
a(b^n) = a b b^{n - 1} = (a b)b^{n - 1} = a'b'^{n'}
$$

$$
\begin{aligned}
a' &= a b \\
b' &= b \\
n' &= n - 1
\end{aligned}
$$

<SchemeCode client:load code={`
(define (fast-expt b n)
  (define (square x) (* x x))
  (define (fast-expt-iter a b n)
    (cond [(= n 0) a]
          [(even? n) (fast-expt-iter a (square b) (/ n 2))]
          [else (fast-expt-iter (* a b) b (- n 1))]))

  (fast-expt-iter 1 b n))

(fast-expt 2 8)
`} />

## 练习 1.17

使用累加法求乘积

$$
a \cdot b = a + a \cdot (b - 1)
$$

<SchemeCode client:load code={`
(define (* a b)
  (if (= b 0)
      0
      (+ a (* a (- b 1)))))

(* 2 8)
`} />

利用 `double` 和 `halve` 在对数时间内求乘积

$$
a \cdot b =
\begin{cases}
(2 \cdot a) \cdot (\frac{1}{2} \cdot b) &, b \text{是偶数} \\
a \cdot (b - 1) + a &, b \text{是奇数} \\
a &, b = 1
\end{cases}
$$

<SchemeCode client:load code={`
(define (double x) (* 2 x))
(define (halve x) (/ x 2))

(define (fast-mul a b)
  (cond [(= b 1) a]
        [(even? b) (double (fast-mul a (halve b)))]
        [else (+ a (fast-mul a (- b 1)))]))

(fast-mul 2 8)
`} />

## 练习 1.18

将 1.17 改为迭代实现

$$
a \times b + c = \begin{cases}
(a \cdot 2) \cdot (\frac{1}{2} \cdot b) + c &,\ b \text{为偶数} \\
a \times (b - 1) + (c + a) &,\ b \text{为奇数} \\
c &,\ b = 0
\end{cases}
$$

<SchemeCode client:load code={`
(define (double x) (* 2 x))
(define (halve x) (/ x 2))

(define (fast-mul a b)
  (define (fast-mul-iter a b c)
    (cond [(= b 0) c]
          [(even? b) (fast-mul-iter (double a) (halve b) c)]
          [else (fast-mul-iter a (- b 1) (+ c a))]))
  (fast-mul-iter a b 0))

(fast-mul 3 4)
`} />

## 练习 1.19

使用对数步数求斐波纳契数列的第n项

$$
\begin{aligned}
a &\gets b q + a q + a p \\
b &\gets b p + a q
\end{aligned}
$$

$$
\begin{aligned}
a' &= b q + a q + a p \\
b' &= b p + a q \\
a'' &= b' q + a' q + a' p \\
    &= (b p + a q) q + (b q + a q + a p) q + (b q + a q + a p) p \\
    &= b p q + a q^2 + b q^2 + a q^2 + a p q + b p q + a p q + a p^2 \\
    &= (p^2 + 2 q^2 + 2 p q)a + (q^2+2 p q)b \\
    &= b(q^2 + 2 p q) + a(q^2 + 2 p q) + a(p^2 + q^2) \\
b'' &= b'p + a'q \\
    &= (b p + a q)p + (b q + a q + a p)q \\
    &= b p^2 + a p q + b q^2 + a q^2 + a p q \\
    &= (q^2 + 2 p q)a + (p ^ 2 + q^2)b \\
    &= b(p^2 + q^2) + a(q^2 + 2p q)
\end{aligned}
$$

$$
\begin{aligned}
p' &= p^2 + q^2 \\
q' &= q^2 + 2 p q
\end{aligned}
$$

<SchemeCode client:load code={`
(define (fib n)
  (define (square x) (* x x))
  (define (fib-iter a b p q count)
    (cond [(= count 0) b]
          [(even? count) (fib-iter a
                                   b
                                   (+ (square p) (square q))
                                   (+ (square q) (* 2 p q))
                                   (/ count 2))]
          [else (fib-iter (+ (* b q) (* a q) (* a p))
                          (+ (* b p) (* a q))
                          p
                          q
                          (- count 1))]))
  (fib-iter 1 0 0 1 n))

(define (f n)
  (define (g i) 
    (if (= i n)
        (cons (fib i) '())
        (cons (fib i) (g (+ i 1)))))
  (g 1))

(f 10)
`} />

## 最大公约数

<SchemeCode client:load code={`
(define (gcd a b)
  (if (= b 0)
      a
      (gcd b (remainder a b))))


(gcd 206 40)
`}/>

## 练习 1.20
使用正则序

```scheme
(gcd 206 40)
(gcd 40 (remainder 206 40)) ; 1
(gcd (remainder 206 40) (remainder 40 (remainder 206 40))) ; 2
(gcd (remainder 40 (remainder 206 40)) (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))) ; 4
(gcd (remainder (remainder 206 40) (remainder 40 (remainder 206 40))) (remainder (remainder 40 (remainder 206 40)) (remainder (remainder 206 40) (remainder 40 (remainder 206 40))))) ; 7
2 ; 4

; 1 + 2 + 4 + 7 + 4 = 18
```

使用应用序

```scheme
(gcd 206 40)
(gcd 40 (remainder 206 40))
(gcd 40 6) ; 1
(gcd 6 (remainder 40 6))
(gcd 6 4) ; 1
(gcd 4 (remainder 6 4))
(gcd 4 2) ; 1
(gcd 2 (remainder 4 2))
2 ; 1

; 1 + 1 + 1 + 1 = 4
```

## 实例 素数检测
$$
\Theta (\sqrt{n})
$$

<SchemeCode client:load code={`
(define (square x) (* x x))

(define (smallest-divisor n)
  (find-divisor n 2))

(define (divides? a  b)
  (= (remainder b a) 0))

(define (find-divisor n test-divisor)
  (cond [(> (square test-divisor) n) n]
        [(divides? test-divisor n) test-divisor]
        [else (find-divisor n (+ test-divisor 1))]))

(define (prime? n)
  (= n (smallest-divisor n)))

(list (prime? 97)
      (prime? 98))
`} />

### 费马小定理

如果 $n$ 是一个素数， $a$ 是小于 $n$ 的任意正整数，那么 $a$ 的 $n$ 次方与 $a$ 模 $n$ 同余。（两个数称为是模 $n$ 同余，如果它们除以 $n$ 的余数相同。数 $a$ 除以 $n$ 的余数称为 $a$ 取模 $n$ 的余数，或简称为 $a$ 取模 $n$ ）

<SchemeCode client:load code={`
(define (square x) (* x x))

(define (expmod base exp m)
  (cond [(= exp 0) 1]
        [(even? exp)
         (remainder (square (expmod base (/ exp 2) m))
                    m)]
        [else
         (remainder (* base (expmod base (- exp 1) m))
                    m)]))

(define (fermat-test n)
  (define (try-it a)
    (= (expmod a n n) a))
  (try-it (+ 1 (random (- n 1)))))

(define (fast-prime? n times)
  (cond [(= times 0) #t]
        [(fermat-test n) (fast-prime? n (- times 1))]
        [else #f]))

(list (fast-prime? 97 3)
      (fast-prime? 98 3))
`} />

对于指数 $e > 1$ 的情况，所采用的规约方式基于以下事实：
对任意的 $x, y, m$ ，有

$$
\def\mod{\ \mathrm{mod}\ }

x\ y \mod m = (x \mod m)(y \mod m) \mod m
$$

例如：在 $e$ 是偶数时，
$$
\def\mod{\ \mathrm{mod}\ }

b^e \mod m = (b^{\frac{e}{2}} \mod m)^2 \mod m
$$

### Carmichael 数
能够骗过费马检查的数称为 Carmichael 数：某些数不是素数却具有这样的性质，对于任意整数 $a < n$，都有 $a^n$ 与 $a$ 模 $n$ 同余。

我们对它们知之甚少，只知其十分罕见。在100 000 000 内有 255 个 Carmichael 数。在检查很大的数是否为素数时，所用的选择是随机的。撞上能欺骗费马检查的值的机会比宇宙射线导致计算机在执行“正确”算法时出错的机会还要小。

## 练习 1.21
找出 199、1999、19999的最小因子

<SchemeCode client:load code={`
(define (square x) (* x x))

(define (divides? a b)
  (= (remainder b a) 0))

(define (find-divisor n test-divisor)
  (cond [(> (square test-divisor) n) n]
        [(divides? test-divisor n) test-divisor]
        [else (find-divisor n (+ test-divisor 1))]))

(define (smallest-divisor n)
  (find-divisor n 2))

(list (smallest-divisor 199)
      (smallest-divisor 1999)
      (smallest-divisor 19999))
`} />

## 练习 1.22

找出大于 1 000、大于 100 000 和大于 1 000 000 的三个最小的素数。

```scheme
(define (timed-prime-test n)
  (newline)
  (display n)
  (start-prime-test n (runtime)))

(define (start-prime-test n start-time)
  (if (prime? n)
      (report-prime (- (runtime) start-time)) #f))

(define (report-prime elapsed-time)
  (display " *** ")
  (display elapsed-time)
  #t)

(define (search-for-primes n)
  (if (even? n)
      (search-for-primes (+ n 1))
      (if (not (timed-prime-test n))
          (search-for-primes (+ n 2)))) )

(search-for-primes 100000)
(search-for-primes 1000000)
(search-for-primes 10000000)

; 100001
; 100003 *** 1
; 1000001
; 1000003 *** 4
; 10000001
; 10000003
; 10000005
; 10000007
; 10000009
; 10000011
; 10000013
; 10000015
; 10000017
; 10000019 *** 11
```

## 练习 1.23
<Todo />

## 练习 1.24
<Todo />

## 练习 1.25
当 $n$ 较大时可能会导致溢出

## 练习 1.26
$$
2^{\log_2{n}} = n
$$

## 练习 1.27

证明 Carmichael 数能够骗过费马检查

<SchemeCode client:load code={`
(define (square x) (* x x))

(define (expmod base exp m)
  (cond [(= exp 0) 1]
        [(even? exp)
         (remainder (square (expmod base (/ exp 2) m))
                    m)]
        [else
         (remainder (* base (expmod base (- exp 1) m))
                    m)]))

(define (full-fermat-test n)
  (define (full-fermat-test-iter a)
    (cond [(= a 1) #t]
          [(not (= (expmod a n n) (remainder a n))) #f]
          [else (full-fermat-test-iter (- a 1))]))
  (full-fermat-test-iter (- n 1)))

(list (full-fermat-test 561)
      (full-fermat-test 1105)
      (full-fermat-test 1729)
      (full-fermat-test 2465)
      (full-fermat-test 2821)
      (full-fermat-test 6601))
`}/>

## 练习 1.28
费马检查的一种不会被欺骗的变形称为 Miller-Rabin 检查
<Todo />

# 1.3 使用高阶函数做抽象

## 求和过程的抽象
序列

$$
\frac{1}{1 \cdot 3} + \frac{1}{5 \cdot 7} +\frac{1}{9 \cdot 11} + \dots
$$
缓慢地收敛到 $\pi/8$

<SchemeCode client:load code={`
(define (cube x) (* x x x))

(define (sum term a next b)
  (if (> a b)
      0
      (+ (term a)
         (sum term (next a) next b))))

(define (inc n) (+ n 1))

(define (sum-cubes a b)
  (sum cube a inc b))

(define (identity x) x)

(define (sum-integers a b)
  (sum identity a inc b))

(define (pi-sum a b)
  (define (pi-term x)
    (/ 1.0 (* x (+ x 2))))
  
  (define (pi-next x)
    (+ x 4))
  (sum pi-term a pi-next b))

(list (sum-integers 1 10)
      (* 8 (pi-sum 1 1000)))
`} />

求积分
求出函数 $f$ 在范围 $a$ 和 $b$ 之间定积分的近似值，可以用下面的公式完成

$$
\newcommand{\f}[1]{f\left( #1 \right)}
\newcommand{\d}{\mathrm{d}}
\int_a^b\ f = \left[ \f{a + \frac{\d x}{2}} + \f{a + \d x + \frac{\d x}{2}} + \f{a + 2\d x + \frac{\d x}{2}} + \dots \right]\d x
$$

<SchemeCode client:load code={`
(define (sum term a next b)
  (if (> a b)
      0
      (+ (term a)
         (sum term (next a) next b))))

(define (cube x) (* x x x))

(define (integral f a b dx)
  (define (add-dx x) (+ x dx))
  (* (sum f (+ a (/ dx 2.0)) add-dx b)
     dx))

(list (integral cube 0 1 0.01)
      (integral cube 0 1 0.001))
`} />

## 练习 1.29

辛普森规则是一种比上面所用规则更精确的数值积分方法。采用辛普森规则，函数 $f$ 在范围 $a$ 和 $b$ 之间的定积分的近似值是：

$$
\frac{h}{3}\left[y_0 + 4 y_1 + 2 y_2 + 4 y_3 + 2 y_4 + \dots + 2 y_{n - 2} + 4 y_{n - 1} + y_n \right]
$$
其中，$h = (b - a) / n$， $n$ 是某个偶数，而 $y_k = f(a + kh)$（增大 $n$ 能提高近似值的精度）

<SchemeCode client:load code={`
(define (sum term a next b)
  (if (> a b)
      0
      (+ (term a)
         (sum term (next a) next b))))

(define (cube x) (* x x x))

(define (inc x) (+ x 1))

(define (simpson-integral f a b n)
  (define (h) (/ (- b a) n))
  (define (y k)
    (f (+ a (* k (h)))))
  (define (t k)
    (cond [(or (= k 0) (= k n)) (y k)]
          [(even? k) (* 2 (y k))]
          [else (* 4 (y k))]))
  (* (/ (h) 3.0)
     (sum t 0 inc n)))

(list (simpson-integral cube 0 1 100)
      (simpson-integral cube 0 1 1000))
`} />

## 练习 1.30

基于迭代的求和函数

<SchemeCode client:load code={`
(define (sum term a next b)
  (define (iter a result)
    (if (> a b)
        result
        (iter (next a) (+ (term a) result))))
  (iter a 0))

(define (pi-sum a b)
  (define (pi-term x)
    (/ 1.0 (* x (+ x 2))))
  
  (define (pi-next x)
    (+ x 4))
  (sum pi-term a pi-next b))

(* 8 (pi-sum 1 1000))
`}/>

## 练习 1.31

定义 `product` 过程，说明如何用 `product` 定义 `factorial`。另外按照下的公式计算 $\pi$ 的近似值。

$$
\frac{\pi}{4} = \frac{2 \cdot 4 \cdot 4 \cdot 6 \cdot 6 \cdot 8 \dots}{3 \cdot 3 \cdot 5 \cdot 5 \cdot 7 \cdot 7 \dots}
$$


上述公式可写成以下形式

$$
\frac{\pi}{2} = \prod_{n=1}^{\infty}\left(\frac{2n}{2n - 1} \cdot \frac{2n}{2n + 1}\right)
$$

<SchemeCode client:load code={`
(define (inc x) (+ x 1))

(define (product factor a next b)
  (if (> a b)
      1
      (* (factor a) (product factor (next a) next b))))

(define (factorial x)
  (product identity 1 inc x))

(define (wallis-product n)
  (define (inc x) (+ 1 x))
  (define (fact n) (* (/ (* 2 n)
                         (- (* 2 n) 1))
                      (/ (* 2 n)
                         (+ (* 2 n) 1))))
  (product fact 1.0 inc n))

(list (factorial 10)
      (* (wallis-product 10000) 2))
`} />

写一个生成迭代过程的 `product` 函数

<SchemeCode client:load code={`
(define (inc x) (+ x 1))

(define (product factor a next b)
  (define (iter a result)
    (if (> a b)
        result
        (iter (next a) (* (factor a) result))))
  (iter a 1))

(define (factorial x)
  (product identity 1 inc x))

(define (wallis-product n)
  (define (inc x) (+ 1 x))
  (define (fact n) (* (/ (* 2 n)
                         (- (* 2 n) 1))
                      (/ (* 2 n)
                         (+ (* 2 n) 1))))
  (product fact 1.0 inc n))

(list (factorial 10)
      (* (wallis-product 10000) 2))
`} />

## 练习 1.32

使用 `accumulate` 实现 `sum` 和 `product`

基于递归计算的实现
<SchemeCode client:load code={`
(define (inc x) (+ x 1))

(define (accmulate combiner null-value term a next b)
  (if (> a b)
      null-value
      (combiner (term a)
                (accmulate combiner
                           null-value
                           term
                           (next a)
                           next
                           b))))

(define (sum term a next b)
  (accmulate + 0 term a next b))

(define (prod factor a next b)
  (accmulate * 1 factor a next b))

(list (sum identity 1 inc 100)
      (prod identity 1 inc 10))
`} />

基于迭代计算的实现

<SchemeCode client:load code={`
(define (inc x) (+ x 1))

(define (accmulate combiner null-value term a next b)
  (define (iter n result)
    (if (> n b)
        result
        (iter (next n) (combiner (term n) result))))
  (iter a null-value))

(define (sum term a next b)
  (accmulate + 0 term a next b))

(define (prod factor a next b)
  (accmulate * 1 factor a next b))

(list (sum identity 1 inc 100)
      (prod identity 1 inc 10))
`} />

## 练习 1.33
实现 `filtered-accumulate`，说明如何用 `filtered-accumulate` 表达以下内容

1. 求出在区间 $a$ 到 $b$ 中所有素数之和（假定你已经写出了谓词 $prime?$ ）
2. 小于 $n$ 的所有与 $n$ 互素的正整数（即所有满足 $\mathrm{GCD}(i, n) = 1, i < n $ 的整数）之乘积

<SchemeCode client:load code={`
(define (filtered-accumulate filter
                             combiner
                             null-value
                             term
                             a
                             next
                             b)
  (define (iter n result)
    (cond [(> n b) result]
          [(not (filter (term n))) (iter (next n) result)]
          [else (iter (next n) (combiner n result))]))
  (iter a null-value))
  
(define (inc x) (+ x 1))

(define (square x) (* x x))

(define (smallest-divisor n)
  (find-divisor n 2))

(define (divides? a b)
  (= (remainder b a) 0))

(define (find-divisor n test-divisor)
  (cond [(> (square test-divisor) n) n]
        [(divides? test-divisor n) test-divisor]
        [else (find-divisor n (+ test-divisor 1))]))

(define (prime? n)
  (if (= n 1) #f
      (= n (smallest-divisor n))))

(define (prime-sum a b)
  (filtered-accumulate prime? + 0 identity a inc b))

(define (gcd a b)
  (if (= b 0)
      a
      (gcd b (remainder a b))))

(define (relative-prime? i n)
  (= (gcd i n) 1))

(define (product-of-relative-prime n)
  (define (relative-prime? i)
    (= (gcd i n) 1))
  (filtered-accumulate relative-prime? * 1 identity 1 inc n))
  
(list (prime-sum 10 15)
      (product-of-relative-prime 10))
`} />

## 练习 1.34
假设我们定义了
```scheme
(define (f g) (g 2))
```
那么就有
<SchemeCode client:load code={`
(define (f g) (g 2))
(define (square x) (* x x))

(list (f square)
      (f (lambda (z) (* z (+ z 1)))))
`} />

那么如果我们要求解释器去求值 `(f f)`，那会发生什么情况？请给出解释。

```
(f f)
(f 2)
(2 2)

application: not a procedure;
 expected a procedure that can be applied to arguments
  given: 2
```

## 实例 通过区间折半寻找方程的根

对于一个连续函数 $f$ ， $f(x) = 0$ 的根可以使用以下步骤寻找
* 如果对于给定点 $a$ 和 $b$ 有 $f(a) < 0 < f(b)$，那么 $f$ 在 $a$ 和 $b$ 之间必有一个零点。
* 为了确定这个零点，令 $x$ 是 $a$ 和 $b$ 的平均值并计算出 $f(x)$。
  * 如果 $f(x) > 0$ ，那么在 $a$ 和 $x$ 之间必然有一个 $f$ 的零点
  * 如果 $f(x) < 0$ ，那么在 $x$ 和 $b$ 之间必然有一个 $f$ 的零点

<SchemeCode client:load code={`
(define (average x y) (/ (+ x y) 2))

(define (search f neg-point pos-point)
  (define (close-enough? x y)
    (< (abs (- x y)) 0.001))

  (let ([midpoint (average neg-point pos-point)])
    (if (close-enough? neg-point pos-point)
        midpoint
        (let ([test-value (f midpoint)])
          (cond [(positive? test-value)
                  (search f neg-point midpoint)]
                [(negative? test-value)
                 (search f midpoint pos-point)])))))

(define (half-interval-method f a b)
  (let ((a-value (f a))
        (b-value (f b)))
    (cond [(and (negative? a-value) (positive? b-value))
            (search f a b)]
           [(and (negative? b-value) (positive? a-value))
            (search f b a)]
           [else
            (error "Values are not of opposite sign" a b)])))

(list (half-interval-method sin 2.0 4.0)
      (half-interval-method (lambda (x) (- (* x x x) (* 2 x) 3))
                            1.0
                            2.0))
`} />

## 实例 找出函数的不动点
数 $x$ 称为函数 $f$ 的不动点，如果 $x$ 满足方程 $f(x) = x$。对于某些函数，通过从某个初始猜测出发，反复应用 $f$

$$
f(x), f(f(x)), f(f(f(x))), \dots
$$

直到值的变化不大时，就可以找到它的一个不动点。

计算某个数 $x$ 的平方根，就是要找到一个 $y$ 使得 $y^2 = x$。

将这一等式变成另一个等价形式 $y = x/y$，就可以发现，这里就是要寻找函数
$$
y \mapsto \frac{x}{y}
$$
的不动点。

遗憾的是，这一不动点搜寻并不收敛。考虑某个初始猜测 $y_1$ ，下一个猜测将是 $y_2 = x / y_1$ ，而再下一个猜测是 $y_3 = x/y_2 = x/(x/y_1) = y_1$。结果是进入了一个无限循环。

控制这类震荡的一种方法是不让有关的猜测变化太剧烈。因为实际答案总是在两个猜测 $y$ 和 $x/y$ 之间，我们可以做出一个猜测，使之不像 $x / y$ 那样远离 $y$ 。

为此可以用 $y$ 和 $x/y$ 的平均值。这样，我们就取 $y$ 之后的下一个猜测值为 $(1/2)(y+x/y)$ 而不是 $x/y$ 。

做出这种猜测序列的计算过程也就是搜寻 $y \mapsto (1/2)(y + x/y)$ 的不动点。

<SchemeCode client:load code={`
(define tolerance 0.00001)

(define (average x y) (/ (+ x y) 2))

(define (fixed-point f first-guess)
  (define (close-enough? v1 v2)
    (< (abs (- v1 v2)) tolerance))
  (define (try guess)
    (let ([next (f guess)])
      (if (close-enough? guess next)
          next
          (try next))))
  (try first-guess))

(define (sqrt x)
  (fixed-point (lambda (y) (average y (/ x y))) 1.0))

(list (fixed-point cos 1.0)
      (fixed-point (lambda (y) (+ (sin y) (cos y))) 1.0)
      (sqrt 4))
`} />

## 练习 1.35
证明黄金分割率 $\phi$ 是变换 $x \mapsto 1 + 1/x$ 的不动点。请利用这一事实，通过过程 `fixed-point` 计算出 $\phi$ 的值
黄金分割率：

$$
\begin{aligned}
\phi^2 &= \phi + 1 \\
\phi &= 1 + 1 / \phi 
\end{aligned}
$$

<SchemeCode client:load code={`
(define tolerance 0.00001)

(define (average x y) (/ (+ x y) 2))

(define (fixed-point f first-guess)
  (define (close-enough? v1 v2)
    (< (abs (- v1 v2)) tolerance))
  (define (try guess)
    (let ([next (f guess)])
      (if (close-enough? guess next)
          next
          (try next))))
  (try first-guess))

(fixed-point (lambda (x) (+ 1 (/ 1 x))) 1.0)
`} />

## 练习 1.36
修改 `fixed-point` ， 使它能打印出计算中产生的近似值序列。

而后通过找出 $ x \mapsto log(1000) / log(x)$ 的不动点的方式，确定 $x^x = 1000$ 的一个根

比较采用平均阻尼和不采用平均组尼时的计算步数

<SchemeCode client:load code={`
(define tolerance 0.00001)

(define (average x y) (/ (+ x y) 2))

(define (fixed-point f first-guess)
  (define (close-enough? v1 v2)
    (< (abs (- v1 v2)) tolerance))
  (define (try guess)
    (display guess)
    (display "; ")
    (let ([next (f guess)])
      (if (close-enough? guess next)
          next
          (try next))))
  (try first-guess))

; 不使用平均阻尼
(fixed-point (lambda (y) (/ (log 1000) (log y))) 1.5)

; 使用平均阻尼
(newline)
(fixed-point (lambda (y) (average y (/ (log 1000) (log y)))) 1.5)
`} />

## 练习 1.37
一个无穷连分式是一个形如以下形式的表达式
$$
f = \frac{N_1}{D_1 + \frac{N_2}{D_2 + \frac{N_3}{D_3 + \dots}}}
$$

在所有的 $N_i$ 和 $D_i$ 都等于 1 时，这一无穷连分式产生出 $1 / \phi$，其中的 $\phi$ 就是黄金分割率。

递归形式
<SchemeCode client:load code={`
(define (cont-frac n d k)
  (define (inner i)
    (if (= i k)
        (/ (n i) (d i))
        (/ (n i) (+ (d i) (inner (+ i 1))))))
  (inner 1))

(cont-frac (lambda (i) 1.0) (lambda (i) 1.0) 100)
`} />

迭代形式
<SchemeCode client:load code={`
(define (cont-frac n d k)
  (define (iter prev i)
    (if (= i 0)
        prev
        (iter (/ (n i) (+ (d i) prev)) (- i 1))))
  (iter 0 k))

(cont-frac (lambda (i) 1.0) (lambda (i) 1.0) 100)
`} />

## 练习 1.38
欧拉提出了一个 $e - 2$ 的连分展开式

在这一分式中， $N_i$ 全部都是 1，而 $D_i$ 依次为 $1, 2, 1, 1, 4, 6, 1, 1, 8, \dots$

<SchemeCode client:load code={`
(define (cont-frac n d k)
  (define (iter prev i)
    (if (= i 0)
        prev
        (iter (/ (n i) (+ (d i) prev)) (- i 1))))
  (iter 0 k))

(define (euler n)
  (cont-frac
   (lambda (i) 1.0)
   (lambda (i)
     (if (= (remainder (+ i 1) 3) 0)
         (* (/ (+ i 1) 3) 2)
         1))
   n))

(+ (euler 100) 2)
`} />

## 练习 1.39
正切函数的连分式为

$$
\tan x = \frac{x}{1 - \frac{x^2}{3 - \frac{x^2}{5 - \ddots}}}
$$

其中 $x$ 用弧度表示

<SchemeCode client:load code={`
(define (cont-frac n d k)
  (define (iter prev i)
    (if (= i 0)
        prev
        (iter (/ (n i) (+ (d i) prev)) (- i 1))))
  (iter 0 k))

(define (tan-cf x k)
  (cont-frac
   (lambda (i)
     (if (= i 1) x (- (* x x))))
   (lambda (i)
     (- (* i 2) 1))
   k))

(tan-cf 3.1415926535 10000)
`} />

## 平均阻尼的过程抽象
求 $y = x/y$ 不动点可以转换为求

$$
y \mapsto (1/2) (y + x/y)
$$

的不动点

<SchemeCode client:load code={`
(define tolerance 0.00001)

(define (average x y) (/ (+ x y) 2))

(define (fixed-point f first-guess)
  (define (close-enough? v1 v2)
    (< (abs (- v1 v2)) tolerance))
  (define (try guess)
    (let ([next (f guess)])
      (if (close-enough? guess next)
          next
          (try next))))
  (try first-guess))

(define (average-damp f)
  (lambda (x) (average x (f x))))

(define (sqrt x)
  (fixed-point (average-damp (lambda (y) (/ x y)))
               1.0))

(sqrt 16)
`} />

## 牛顿法的一般情况

如果 $x \mapsto g(x)$ 是一个可微函数，那么方程 $g(x) = 0$的一个解就是函数 $x \mapsto f(x)$ 的一个不动点，其中：

$$
f(x) = x - \frac{g(x)}{Dg(x)}
$$

这里的 $Dg(x)$ 是 $g$ 对 $x$ 的导数。

$$
Dg(x) = \frac{g(x + \mathrm{d}x) - g(x)}{\mathrm{d}x}
$$

<SchemeCode client:load code={`
(define (square x) (* x x))

(define tolerance 0.00001)

(define (average x y) (/ (+ x y) 2))

(define (fixed-point f first-guess)
  (define (close-enough? v1 v2)
    (< (abs (- v1 v2)) tolerance))
  (define (try guess)
    (let ([next (f guess)])
      (if (close-enough? guess next)
          next
          (try next))))
  (try first-guess))

(define dx 0.00001)

(define (deriv g)
  (lambda (x)
    (/ (- (g ( + x dx)) (g x))
       dx)))

(define (newton-transform g)
  (lambda (x)
    (- x (/ (g x) ((deriv g) x)))))

(define (newtons-method g guess)
  (fixed-point (newton-transform g) guess))

(define (sqrt x)
  (newtons-method (lambda (y) (- (square y) x))
                  1.0))

(sqrt 16)
`} />

## 抽象和第一级过程
<SchemeCode client:load code={`
; fixed-point
(define tolerance 0.00001)

(define (average x y) (/ (+ x y) 2))

(define (fixed-point f first-guess)
  (define (close-enough? v1 v2)
    (< (abs (- v1 v2)) tolerance))
  (define (try guess)
    (let ([next (f guess)])
      (if (close-enough? guess next)
          next
          (try next))))
  (try first-guess))

; derivative
(define dx 0.00001)

(define (deriv g)
  (lambda (x)
    (/ (- (g ( + x dx)) (g x))
       dx)))

; newton method
(define (newton-transform g)
  (lambda (x)
    (- x (/ (g x) ((deriv g) x)))))

(define (newtons-method g guess)
  (fixed-point (newton-transform g) guess))

; average damp
(define (average-damp f)
  (lambda (x) (average x (f x))))

(define (square x) (* x x))

(define (fixed-point-of-transform g transform guess)
  (fixed-point (transform g) guess))

(define (sqrt1 x)
  (fixed-point-of-transform (lambda (y) (/ x y))
                            average-damp
                            1.0))

(define (sqrt2 x)
  (fixed-point-of-transform (lambda (y) (- (square y) x))
                            newton-transform
                            1.0))

(list (sqrt1 16)
      (sqrt2 16))
`} />

## 练习 1.40
定义 `cubic`，使用牛顿法逼近三次方程 $x^3 + ax^2 + bx + c$ 的零点

<SchemeCode client:load code={`
; fixed-point
(define tolerance 0.00001)

(define (average x y) (/ (+ x y) 2))

(define (fixed-point f first-guess)
  (define (close-enough? v1 v2)
    (< (abs (- v1 v2)) tolerance))
  (define (try guess)
    (let ([next (f guess)])
      (if (close-enough? guess next)
          next
          (try next))))
  (try first-guess))

; derivative
(define dx 0.00001)

(define (deriv g)
  (lambda (x)
    (/ (- (g ( + x dx)) (g x))
       dx)))

; newton method
(define (newton-transform g)
  (lambda (x)
    (- x (/ (g x) ((deriv g) x)))))

(define (newtons-method g guess)
  (fixed-point (newton-transform g) guess))

(define (cubic a b c)
  (lambda (x)
    (+ (* x x x) (* a x x) (* b x) c)))

(newtons-method (cubic 1 1 1) 1)
`} />

## 练习 1.41

`double`

<SchemeCode client:load code={`
(define (inc x) (+ x 1))

(define (double f)
  (lambda (x)
    (f (f x))))

(((double (double double)) inc) 5)
`} />

## 练习 1.42

`compose`

<SchemeCode client:load code={`
(define (suqare x) (* x x))
(define (inc x) (+ x 1))

(define (compose f g)
  (lambda (x) (f (g x))))

((compose square inc) 6)
`} />

## 练习 1.43

`repeated`

<SchemeCode client:load code={`
(define (square x) (* x x))
(define (repeated f count)
  (define (iter counter inner-result)
    (if (= counter 0)
        inner-result
        (iter (- counter 1) (f inner-result))))
  (lambda (x) (iter count x)))

((repeated square 2) 5)
`} />

## 练习 1.44

`smooth`

```scheme
(define (smooth f)
  (define (dx) 0.0001)
  (lambda (x)
    (/ (+ (f (- x dx)) (f x) (f (+ x dx))) 3)))
```

## 练习 1.45

TODO

## 练习 1.46

TODO